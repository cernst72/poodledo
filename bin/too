#!/usr/bin/env python

import ast
from importlib.metadata import requires
from linecache import cache
import logging
import os
import webbrowser
from datetime import datetime, timedelta
from time import mktime, time

import click
import parsedatetime as pdt
from dateutil import tz
from poodledo import config
from poodledo import apiclient
from poodledo.apiclient import PoodledoError
from poodledo.cli import do_login
from poodledo.lexer import parse
from poodledo.toodledodata import ToodledoData

logger = logging.getLogger(__name__)
api_client = None


@click.group()
@click.option('-v', '--verbose', 'verbose', default=False, is_flag=True, help='verbose output')
def cli(verbose):
    if verbose:
        logging.basicConfig(level=logging.DEBUG)
        logger.setLevel(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)
        logger.setLevel(level=logging.INFO)


@cli.command(help='list relevant tasks (optionaly with -a)')
@click.option('-c', '--context', 'context')
@click.option('-a', '--all', 'list_size', count=True, help='show additional tasks (tomorrow + task without due date)')
def ls(context=None, list_size=0):
    list_tasks(context, list_size)


@cli.command(help='list new tasks')
def inbox(context=None, list_size=0):
    list_tasks_inbox()


@cli.command(help='show task details')
@click.argument('task', required=True, type=click.INT)
def show(task):
    logger.debug("show " + str(task))
    tasks = read_cache()
    print(tasks[task - 1])

@cli.command(name='open', help='open task in browser')
@click.argument('task', required=False, type=click.INT)
def open_task(task):
    url = "https://tasks.toodledo.com/main"
    if (task and task > 0):
        print("task" + str(task))
        logger.debug("open " + str(task))
        task = read_cache()[task - 1]
        logger.info("Open task '%s'" % task.title)
        url += "/-10/" + str(task.id)
    else:
        url += "/-9/"
    webbrowser.open_new_tab(url)


@cli.command(help='add new task, Example: \'add task do something .saturday @@context\'')
@click.argument('line', nargs=-1)
def add(line):
    task = parse(" ".join(line))
    if 'duedate' not in task:
        task['duedate'] = time()
    logger.info("add task: " + str(task))
    get_client()
    api_client.addTask(**task)
    invalidate_cache()

@cli.command(help='edit task')
@click.argument('task', required=True, type=click.INT)
@click.argument('line', nargs=-1)
# @click.argument('modification', required=True, type=click.STRING)
def edit(task, line):
    # edit 2 '?some note'
    # edit 2 '.next monday'
    # edit 2 '=14:00'
    # edit 2 '$next action'
    # edit 2 '@@work'
    # edit 2 '!!!'
    # edit 2 ':1'
    task = read_cache()[task - 1]
    new_task = parse(" ".join(line))
    if not "title" in new_task or new_task["title"] == '':
        new_task["title"] = task.title
    logger.info("Edit %d, '%s' to %s" % (task.id, task.title, new_task))
    get_client()
    api_client.editTask(task, **new_task)


@cli.command(help='mark task as complete')
@click.argument('task', required=True, type=click.INT)
def check(task):
    task = read_cache()[task - 1]
    logger.info("Marking task %d '%s' as complete" % (task.id, task.title))
    get_client()
    task = api_client.getTask(task.id, cache=False, comp=False)
    api_client.editTask(task, completed=time(), reschedule=1)
    invalidate_cache()


def list_tasks(context=None, list_size=0):
    get_client()
    tasks = get_tasks(None, 'today', context)
    if list_size == 0:
        tasks += get_tasks('today', 'tomorrow+1', context)
        tasks += get_tasks(None, None, context, 'next action')
    if list_size > 0:
        tasks += get_tasks(None, 'tomorrow+364 days', context)
        tasks += get_tasks(None, None, context)
    write_cache(tasks)
    print_tasks(tasks)

def list_tasks_inbox():
    get_client()
    raw_tasks = api_client.getTasks(cache=True, comp=False)
    tasks = [x for x in raw_tasks if x.context == '0' or x.status == 0]
    write_cache(tasks)
    print_tasks(tasks)




def get_tasks(day_start=None, day_end='today', context=None, status=None):
    context_id = api_client.translate('context', context) if context else 0
    status_id = api_client.translate('status', status) if status else 0
    start = get_max_time(day_start) if day_start else None
    end = get_max_time(day_end) if day_end else None
    raw_tasks = [x for x in
                 api_client.getTasks(cache=True, comp=False)]
    tasks = [x for x in raw_tasks if is_in(x, start, end, context_id, status_id)]
    tasks.sort(key=lambda x: (-(x.priority), x.duedate,
               (x.duetime <= 0), x.duetime, x.status, x.context))
    return tasks


def is_in(item, start_date, end_date, context_id, status_id):
    if ((not item.duedate and not start_date and not end_date)
        or (item.duedate and end_date and int(item.duedate) < end_date)
        and (not start_date or (item.duedate and int(item.duedate) > start_date))) \
            and (context_id == 0 or context_id == int(item.context) or int(item.context) == 0) \
            and (status_id == 0 or status_id == int(item.status) or int(item.status) == 0):
        return True
    else:
        return False

def toToodleTask(elem):
    return ToodledoData(elem, "task")

def write_cache(tasks):
    cache_file = os.path.join(config.CONFIGDIR, "tasks.json")
    with open(cache_file, "w") as f:
        f.write(repr(tasks))

def read_cache():
    cache_file = os.path.join(config.CONFIGDIR, "tasks.json")
    try:
        with open(cache_file, 'r') as f:
            tasks = ast.literal_eval(f.read())
        return [toToodleTask(elem) for elem in tasks]
    except IOError as error: 
        print("No valid cache. First you must read via commands 'ls' or 'inbox'.")
        exit(-1)


def invalidate_cache():
    cache_file = os.path.join(config.CONFIGDIR, "tasks.json")
    if (os.path.exists(cache_file)):
        os.remove(cache_file)

def print_tasks(tasks):
    if not tasks:
        print("No tasks found. Go home early!")
    for item in tasks:
        output = [f"{str(tasks.index(item) + 1):2}",
                  "(%s)" % format_priority(item.priority),
                  f"{item.title:50.50}",
                  f"{format_date(item.duedate):9.9}",
                  f"{format_time(item.duetime):5.5}",
                  f"{format_context(item.context):15.15}",
                  f"{format_status(item.status):11.11}"]
        print((" ".join(output)))


def format_date(timestamp):
    return datetime.fromtimestamp(timestamp, tz.tzutc()).strftime('%a %d.%m') if timestamp > 0 else ""


def format_time(timestamp):
    return datetime.fromtimestamp(timestamp, tz.tzutc()).strftime('%H:%M') if timestamp > 0 else ""


def format_context(id):
    contextDict = {x['id']: x['name'] for x in api_client.getContexts()}
    return str(contextDict.get(int(id)))


def format_status(id):
    statuses = [
        'none',
        'next action',
        'active',
        'planning',
        'delegated',
        'waiting',
        'hold',
        'postponed',
        'someday',
        'canceled',
        'reference'
        ]
    return str(statuses[id])


def format_priority(id):
    return str(['D', 'C', 'B', 'A', 'E'][id])


def get_max_time(day='today'):
    timest = pdt.Calendar().parse(day)[0]
    now = datetime.fromtimestamp(mktime(timest), tz.tzlocal())
    daystart = datetime(now.year, now.month, now.day, tzinfo=now.tzinfo)
    dayend = daystart + timedelta(days=1)
    utc_dayend = mktime(dayend.timetuple())
    return utc_dayend


def get_client():
    global api_client
    try:
        api_client = do_login()
    except PoodledoError as e:
        print(e)
        exit(1)


if __name__ == '__main__':
    cli()
