#!/usr/bin/env python

import ast
import logging
import os
import webbrowser
from collections import defaultdict
from datetime import datetime, timedelta
from importlib.metadata import requires
from linecache import cache
from time import mktime, time

import click
import parsedatetime as pdt
from dateutil import tz

from poodledo import apiclient, config
from poodledo.apiclient import ApiClient, PoodledoError
from poodledo.cli import do_login
from poodledo.lexer import parse
from poodledo.toodledodata import ToodledoData

logger = logging.getLogger(__name__)
api_client : ApiClient = None


@click.group()
@click.option('-v', '--verbose', 'verbose', default=False, is_flag=True, help='verbose output')
def cli(verbose):
    if verbose:
        logging.basicConfig(level=logging.DEBUG)
        logger.setLevel(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)
        logger.setLevel(level=logging.INFO)


@cli.command(help='list relevant tasks (optionaly with -a)')
@click.option('-c', '--context', 'context')
@click.option('-a', '--all', 'list_size', count=True, help='show additional tasks (tomorrow + task without due date)')
@click.option('-i', '--priority-level', 'priority_level_sort', is_flag=True, help='sort by priority level')
def ls(context=None, list_size=0, priority_level_sort=False):
    list_tasks(context, list_size, priority_level_sort)


@cli.command(help='list new tasks')
def inbox(context=None, list_size=0):
    list_tasks_inbox()


@cli.command(help='show task details')
@click.argument('task', required=True, type=click.INT)
def show(task):
    task = read_cache()[task - 1]
    logger.debug("task: %s" % task.dict())
    print(task)

@cli.command(name='open', help='open task in browser')
@click.argument('task', required=False, type=click.INT)
def open_task(task):
    url = "https://tasks.toodledo.com/main"
    if (task and task > 0):
        print("task" + str(task))
        logger.debug("open " + str(task))
        task = read_cache()[task - 1]
        logger.info("Open task '%s'" % task.title)
        url += "/-10/" + str(task.id)
    else:
        url += "/-9/"
    webbrowser.open_new_tab(url)


@cli.command(help='add new task, Example: \'add task do something .saturday @@context\'')
@click.argument('line', nargs=-1)
def add(line):
    task = parse(" ".join(line))
    logger.info("add task: " + str(task))
    get_client().addTask(**task)
    invalidate_cache()

@cli.command()
@click.argument('task', required=True, type=click.INT)
@click.argument('line', nargs=-1)
# @click.argument('modification', required=True, type=click.STRING)
def edit(task, line):
    """
    edit task

    edit 1 \' ?some note .monday =14:00 :1 $next action @@work !2 *\'
    """
    # edit 2 ' ?some note' # append to note
    # edit 2 ' ? ' # deletes note
    # edit 2 '.next monday'
    # edit 2 '=14:00'
    # edit 2 '$next action'
    # edit 2 '@@work'
    # edit 2 '!2'
    # edit 2 ':1'
    old_task = read_cache()[task - 1]
    new_task = parse(" ".join(line))
    if not "title" in new_task or new_task["title"] == '':
        new_task["title"] = old_task.title
    if "star" in new_task and new_task["star"]:
        new_task["star"] = not old_task.star
    if "note" in new_task and new_task["note"] and old_task.note:
        new_task["note"] = old_task.note + "\n" + new_task["note"]
    logger.info("Edit %d, '%s' to %s" % (old_task.id, old_task.title, new_task))
    get_client().editTask(old_task, **new_task)


@cli.command(help='mark task as complete')
@click.argument('task', required=True, type=click.INT)
def check(task):
    task = read_cache()[task - 1]
    logger.info("Marking task %d '%s' as complete" % (task.id, task.title))
    get_client()
    task = api_client.getTask(task.id, cache=False, comp=False)
    api_client.editTask(task, completed=time(), reschedule=1)


def list_tasks(context, list_size, priority_level_sort):
    get_client()
    tasks = get_tasks(None, 'today', context)
    if list_size == 0:
        tasks += get_tasks('today', 'in 3 days', context)
        tasks += get_tasks(None, None, context, 'next action')
    if list_size > 0:
        tasks += get_tasks('today', 'tomorrow+364 days', context)
        tasks += get_tasks(None, None, context)
    if (priority_level_sort):
        tasks.sort(key=lambda x: priority_level(x), reverse=True)
    write_cache(tasks)
    print_tasks(tasks, priority_level_sort)

def list_tasks_inbox():
    get_client()
    raw_tasks = api_client.getTasks(cache=True, comp=False)
    tasks = [x for x in raw_tasks if x.context == '0' or x.status == 0]
    write_cache(tasks)
    print_tasks(tasks)


def get_tasks(day_start=None, day_end='today', context=None, status=None):
    context_id = api_client.translate('context', context) if context else 0
    status_id = api_client.translate('status', status) if status else 0
    start = get_max_time(day_start) if day_start else None
    end = get_max_time(day_end) if day_end else None
    raw_tasks = [x for x in
                 api_client.getTasks(cache=True, comp=False)]
    tasks = [x for x in raw_tasks if is_in(x, start, end, context_id, status_id)]
    tasks.sort(key=lambda x: (x.duedate,
               (x.duetime <= 0),
               x.duetime,
               -(x.priority),
               x.status,
               x.context,
               x.title.upper()))
    return tasks


def is_in(item, start_date, end_date, context_id, status_id):
    if ((not item.duedate and not start_date and not end_date)
        or (item.duedate and end_date and int(item.duedate) < end_date)
        and (not start_date or (item.duedate and int(item.duedate) > start_date))) \
            and (context_id == 0 or context_id == int(item.context) or int(item.context) == 0) \
            and (status_id == 0 or status_id == int(item.status) or int(item.status) == 0):
        return True
    else:
        return False

def toToodleTask(elem) -> ToodledoData:
    return ToodledoData(elem, "task")

def write_cache(tasks):
    cache_file = os.path.join(config.CONFIGDIR, "tasks.json")
    with open(cache_file, "w") as f:
        f.write(repr(tasks))

def read_cache():
    cache_file = os.path.join(config.CONFIGDIR, "tasks.json")
    try:
        with open(cache_file, 'r') as f:
            tasks = ast.literal_eval(f.read())
        return [toToodleTask(elem) for elem in tasks]
    except IOError as error:
        print("No valid cache. First you must read via commands 'ls' or 'inbox'.")
        exit(-1)


def invalidate_cache():
    cache_file = os.path.join(config.CONFIGDIR, "tasks.json")
    if (os.path.exists(cache_file)):
        os.remove(cache_file)


def print_tasks(tasks, priority_level_sort=False):
    if not tasks:
        print("No tasks found. Go home early!")
    if (priority_level_sort):
        tasks_by_prio = defaultdict(list)
        for task in tasks:
            tasks_by_prio[priority_level(task)].append(task)
        for prio, items in tasks_by_prio.items():
            #print("--------------------------------------")
            print()
            print_task_list(tasks, items)
    else:
        print_task_list(tasks, tasks)

def print_task_list(tasks, items):
    for item in items:
        output = [f"{str(tasks.index(item) + 1):2}",
                  "(%s)" % format_priority(item.priority),
                  "%s" % "*" if item.star else " ",
                  f"{item.title:50.50}",
                  f"{format_date(item.duedate):9.9}",
                  f"{format_time(item.duetime):5.5}",
                  f"{(item.remind if int(item.remind) > 0 else ''):2.2}",
                  f"{format_context(item.context):15.15}",
                  f"{format_status(item.status):11.11}",
                  f"{priority_level(item):3}"]
        print(" ".join(output))


def format_date(timestamp):
    return datetime.fromtimestamp(timestamp, tz.tzutc()).strftime('%a %d.%m') if timestamp > 0 else ""


def format_time(timestamp):
    return datetime.fromtimestamp(timestamp, tz.tzutc()).strftime('%H:%M') if timestamp > 0 else ""


def format_context(id):
    contextDict = {x['id']: x['name'] for x in api_client.getContexts()}
    return str(contextDict.get(int(id)))


def format_status(id):
    statuses = [
        'none',
        'next action',
        'active',
        'planning',
        'delegated',
        'waiting',
        'hold',
        'postponed',
        'someday',
        'canceled',
        'reference'
        ]
    return str(statuses[id])


def format_priority(id):
    return str(['D', 'C', 'B', 'A', 'E'][id])


def get_max_time(day='today'):
    timest = pdt.Calendar().parse(day)[0]
    now = datetime.fromtimestamp(mktime(timest), tz.tzlocal())
    daystart = datetime(now.year, now.month, now.day, tzinfo=now.tzinfo)
    dayend = daystart + timedelta(days=1)
    utc_dayend = mktime(dayend.timetuple())
    return utc_dayend

def priority_level(item):
    today = datetime.today()
    if (item.duedate > 0):
        duedate = datetime.fromtimestamp(int(item.duedate))
        datediff = (duedate - today).days
        if (datediff < 0):
            datepoints = 6
        elif (datediff == 0):
            datepoints = 5
        elif (datediff == 1):
            datepoints = 3
        elif (datediff > 1 and datediff <= 7):
            datepoints = 2
        elif (datediff > 7 and datediff <= 14):
            datepoints = 1
        else:
            datepoints = 0
    else:
        datepoints = 0
    return 2 + int(item.priority) + (1 if item.star else 0) + datepoints + (-1 if item.status != 1 else 0)

def get_client() -> ApiClient:
    global api_client
    if api_client:
        return api_client
    try:
        api_client = do_login()
        return api_client
    except PoodledoError as e:
        print(e)
        exit(1)


if __name__ == '__main__':
    cli()
